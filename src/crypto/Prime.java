package crypto;

import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Random;

/**
 * A class containing functions for generating primes and testing primality.
 * @author Jack
 * @version 1.5 Alpha
 */
public class Prime {
    
    /**
     * An int[] of the primes under 1000 as generated by the eratosthenes() method.
     */
    public static int[] primesBelow1000 = eratosthenes(1000);
    
    /**
     * Generates all primes less than the number 'n' using the Sieve of Eratosthenes
     * @param n The maximum value for your primes
     * @return An integer array containing all primes less than the value
     */
    public static int[] eratosthenes(int n) {
        
        //Fill an array with all numbers under n
        int[] possiblePrimes = new int[n-1];
        for(int x = 0; x < n-1; x++){
            possiblePrimes[x] = x + 2;
        }
        //Iterate through and remove all multiples of the numbers it encounters
        for(int x = 0; x < possiblePrimes.length; x++) {
            int mul = possiblePrimes[x]*2;
            while (mul <= possiblePrimes[possiblePrimes.length - 1]) {
                //Remove the multiple from the array
                int index = Arrays.binarySearch(possiblePrimes, mul);
                if (index >= 0) {
                    int[] temp = new int[possiblePrimes.length - 1];
                    System.arraycopy(possiblePrimes, 0, temp, 0, index);
                    System.arraycopy(possiblePrimes, index+1, temp, index, temp.length - index);
                    possiblePrimes = temp;
                }
                //Jump to next multiple
                mul += possiblePrimes[x];
            }
        }
        return possiblePrimes;
                
    }
    
    /**
     * Performs a Fermat primality test on the given BigInteger.
     * @param n The BigInteger to test.
     * @return True if it is a Fermat probable prime using the internally generated number, or false if not.
     */
    public static boolean fermat(BigInteger n) {
        BigInteger a = getRandomBigInteger(n);
        return a.modPow(n.subtract(BigInteger.ONE), n).equals(BigInteger.ONE);
    }
    
    /**
     * Performs a Fermat primality test on the given BigInteger.
     * @param n The BigInteger to test.
     * @param a The BigInteger to use as a test value, given that a is larger than n.
     * @return True if n is a Fermat probable prime using the given number a, or false if not.
     */
    public static boolean fermat(BigInteger n, BigInteger a) {
        return a.modPow(n.subtract(BigInteger.ONE), n).equals(BigInteger.ONE);
    }
    
    /**
     * Gets a new random BigInteger less than the given number.
     * @param n The exclusive maximum.
     * @return The generated BigInteger.
     */
    public static BigInteger getRandomBigInteger(BigInteger n) {
        Random rnd = new Random();
        do {
            BigInteger i = new BigInteger(n.bitLength(), rnd).add(new BigInteger("2"));
            System.out.println(i.intValue() + " " + n.intValue());
            if (i.compareTo(n) < 0)
                return i;
        } while (true);
    }
    
    /**
     * Performs the Miller-Rabin primality test on the given BigInteger n with k iterations.
     * @param n The BigInteger to perform the test on.
     * @param k Number of Miller-Rabin iterations to perform. Error bounds is something like 4^-k.
     * @return Whether or not the BigInteger is prime based on the internally generated test values.
     */
    public static boolean millerRabin(BigInteger n, int k) {
        if (!testSimpleConditions(n)) return false;
        if (n.equals(new BigInteger("2"))) {
            return true;
        } else if(n.mod(new BigInteger("2")).equals(BigInteger.ZERO)) {
            return false;
        }
        boolean isPrime = true;
        for (int x = 0; x < k; x++) {
            if (!singleMillerRabin(n)) {
                isPrime = false;
            }
        }
        return isPrime;
    }    
    
    private static boolean singleMillerRabin(BigInteger n) {
        BigInteger a = getRandomBigInteger(n);
        int s = 0;
        BigInteger d = n.subtract(BigInteger.ONE);
        //Factor out powers of two (d*(2^s) = n)
        while (d.mod(new BigInteger("2")).equals(BigInteger.ZERO)) {
            d = d.divide(new BigInteger("2"));
            s++;
        }
        int pow = 0;
        do {
            BigInteger res = a.modPow(d.multiply(new BigInteger((int)Math.pow(2, pow) + "")), n);
            if (res.equals(n.subtract(BigInteger.ONE)) || res.equals(BigInteger.ONE)) {
                return true;
            }
            pow++;
        } while (pow < s);
        return false;
    }
    
    /**
     * Performs the Solovay-Strassen primality test on the given BigInteger n with k iterations.
     * @param n The BigInteger to perform the test on.
     * @param k Number of Solovay-Strassen iterations to perform.
     * @return Whether or not the BigInteger is prime based on the internally generated test value.
     */
    public static boolean solovayStrassen(BigInteger n, int k) {
        if (!testSimpleConditions(n)) return false;
        boolean isPrime = true;
        for(int c = 0; c < k; c++) {
            BigInteger a = getRandomBigInteger(n);
            int jacobi = jacobi(a, n);
            BigInteger jacobiModN = new BigInteger(""+jacobi).mod(n);
            BigInteger x = a.modPow(n.subtract(BigInteger.ONE).divide(new BigInteger("2")), n);
            if (!x.equals(jacobiModN) && !x.equals(BigInteger.ZERO) ) {
                isPrime = false;
                break;
            }
        }
        return isPrime;
    }
    
    /**
     * Calculates the Jacobi symbol for the given a/n.
     * @param a The numerator of the Jacobi calculation.
     * @param n The denominator of the Jacobi calculation.
     * @return The Jacobi symbol for the given a/n
     */
    public static int jacobi(BigInteger a, BigInteger n) {
        int signsymbol = 1;
        if (a.compareTo(BigInteger.ZERO) < 0) {
            signsymbol = -1;
            a = a.negate();
        }
        a = a.mod(n);
        int pow2 = 0;
        while (a.compareTo(new BigInteger("2")) > 0 && a.mod(new BigInteger("2")).equals(BigInteger.ZERO)) {
            a = a.divide(new BigInteger("2"));
            pow2++;
        }
        if (pow2 > 0) {
            int nfrom2s = 0;
            int res = n.mod(new BigInteger("8")).intValue();
            if(res == 1 || res == 7) {
                nfrom2s = 1;
            } else if (res == 3 || res == 5) {
                nfrom2s = -1;
            } else {
                System.err.println("Denominator (n) is even!");
                return 0;
            }
            signsymbol *= (int)Math.pow(nfrom2s, pow2);
        }
        if(a.equals(BigInteger.ONE)) {
            return 1*signsymbol;
        }
        if(!a.gcd(n).equals(BigInteger.ONE)) {
            return 0;
        }
        int asignflip = a.mod(new BigInteger("4")).intValue();
        int bsignflip = n.mod(new BigInteger("4")).intValue();
        if(asignflip==3&&bsignflip==3) {
            signsymbol *= -1;
            if (signsymbol < 0) n = n.negate();
            return jacobi(n, a);
        } else {
            if (signsymbol < 0) n = n.negate();
            return jacobi(n, a);
        }
    }
    
    /**
     * Performs the Lucas primality test on a given BigInteger.
     * @param n The number to perform the test on.
     * @return Whether or not the number is a prime under the generated integer.
     */
    public static boolean lucas(BigInteger n) {
        BigInteger a = getRandomBigInteger(n);
        if (!a.modPow(n.subtract(BigInteger.ONE), n).equals(BigInteger.ONE)) {
            return false;
        }
        int[] qs = primeFactors(n.subtract(BigInteger.ONE));
        for(int q: qs) {
            if (a.modPow(n.subtract(BigInteger.ONE).divide(new BigInteger(""+q)), n).equals(1)) {
                return false;
            }
        }
        return true;
    }
    
    /**
     * Perform a strong Lucas Probable Primality test on a given number.
     * @param n The number to test.
     * @param testSimpleConditions Whether or not to test divisibility by small primes, whether it's a perfect square, and whether it's even.
     * @return Whether or not the number is a strong Lucas probable prime.
     */
    public static boolean strongLucas(BigInteger n, boolean testSimpleConditions) {
        if (testSimpleConditions){
            if(!testSimpleConditions(n)) return false;
        }
        //Get D, P, Q
        int D = 5;
        int jacobi = jacobi(new BigInteger(""+D), n);
        while (jacobi >= 0) {
            D = (D+2)*-1;
            jacobi = jacobi(new BigInteger(""+D), n);
        }
        int P = 1, Q = (D-1)/4;
        //Check if n has any factors in common with P or Q
        if (!n.gcd(new BigInteger(""+P)).equals(BigInteger.ONE) || !n.gcd(new BigInteger(""+Q)).equals(BigInteger.ONE) || 
                !n.gcd(new BigInteger(""+D)).equals(BigInteger.ONE)) return false;
        //Perform rest of test
        BigInteger phi = n.subtract(new BigInteger(""+jacobi));
        //Factor out powers of two (d*(2^s) = n)
        BigInteger d = phi;
        int s = 0;
        while (d.mod(new BigInteger("2")).equals(BigInteger.ZERO)) {
            d = d.divide(new BigInteger("2"));
            s++;
        }
        //hanging because s is 1 and it can't gen numbers less than like 3
        int r = getRandomBigInteger(new BigInteger(""+s)).intValue();
        //r will probably be within int range, because 2^25000 is ridiculously huge, and we don't ever need numbers that big.
        if (!lucasNumberUk(d, P, Q).mod(n).equals(BigInteger.ZERO) && 
                !lucasNumberVk(d.multiply(new BigInteger(""+(int)Math.pow(2, r))), P, Q).mod(n).equals(BigInteger.ZERO)) {
            return false;
        }
        return true;
    }
    
    /**
     * Get Un in the Lucas sequence Uk(P, Q)
     * @param n The index of the value you want (Un)
     * @param P The P-value to use
     * @param Q The Q-value to use
     * @return The number Un from sequence Uk(P, Q)
     */
    public static BigInteger lucasNumberUk(BigInteger n, int P, int Q) {
        if (n.equals(BigInteger.ZERO)) {
            return BigInteger.ZERO;
        }
        if (n.equals(BigInteger.ONE)) {
            return BigInteger.ONE;
        }
        System.out.println("CycleUk");
        return lucasNumberUk(n.subtract(BigInteger.ONE), P, Q).multiply(new BigInteger(""+P))
                .subtract(lucasNumberUk(n.subtract(new BigInteger("2")), P, Q).multiply(new BigInteger(""+Q)));
    }
    
    /**
     * Get Vn in the Lucas sequence Vk(P, Q)
     * @param n The index of the value you want (Vn)
     * @param P The P-value to use
     * @param Q The Q-value to use
     * @return The number Un from sequence Vk(P, Q)
     */
    public static BigInteger lucasNumberVk(BigInteger n, int P, int Q) {
        if (n.equals(BigInteger.ZERO)) {
            return new BigInteger("2");
        }
        if (n.equals(BigInteger.ONE)) {
            return new BigInteger(""+P);
        }
        System.out.println("CycleVk");
        return lucasNumberVk(n.subtract(BigInteger.ONE), P, Q).multiply(new BigInteger(""+P))
                .subtract(lucasNumberVk(n.subtract(new BigInteger("2")), P, Q).multiply(new BigInteger(""+Q)));
    }
    
    /**
     * Compute the square root of a given BigInteger
     * @param n The number to take the square root of.
     * @return The square root.
     */
    public static BigInteger sqrt(BigInteger n)
    {
        if (n.signum() >= 0)
        {
            final int bitLength = n.bitLength();
            BigInteger root = BigInteger.ONE.shiftLeft(bitLength / 2);

            while (!isSqrt(n, root))
            {
                root = root.add(n.divide(root)).divide(new BigInteger("2"));
            }
            return root;
        }
        else
        {
            throw new ArithmeticException("Cannot take square root of negative number.");
        }
    }
    
    private static boolean isSqrt(BigInteger n, BigInteger root)
    {
        final BigInteger lowerBound = root.pow(2);
        final BigInteger upperBound = root.add(BigInteger.ONE).pow(2);
        return lowerBound.compareTo(n) <= 0
            && n.compareTo(upperBound) < 0;
    }

    
    /**
     * Get the prime factors of a BigInteger.
     * @param n The number to factor.
     * @return An array of the prime factors of that number.
     */
    public static int[] primeFactors(BigInteger n) {
        List<BigInteger> factors = new ArrayList();
        for (BigInteger i = new BigInteger("2"); i.compareTo(n) <= 0; i = i.add(BigInteger.ONE)) {
          while (n.mod(i).equals(BigInteger.ZERO)) {
            factors.add(i);
            n = n.divide(i);
          }
        }
        int[] factorInts = new int[factors.size()];
        for(int i = 0; i < factors.size(); i++) factorInts[i] = factors.get(i).intValue();
        return factorInts;
    }
    
    /**
     * Performs the Baillie-PSW Primality Test on a given BigInteger.
     * @param n The integer to test.
     * @return Whether or not the integer is probably prime.
     */
    public static boolean bailliePSW(BigInteger n) {
        if (!testSimpleConditions(n)) return false;
        if (!singleMillerRabin(n)) {
            return false;
        }
        if (!strongLucas(n, false)) {
            return false;
        }
        return true;
    }
    
    private static boolean testSimpleConditions(BigInteger n) {
        //Make sure it's odd, not a perfect square, and not divisible by any primes under 1000.
        if(n.mod(new BigInteger("2")).equals(BigInteger.ZERO) && !n.equals(new BigInteger("2"))) {
            return false;
        }
        if(sqrt(n).pow(2).equals(n)){
            return false;
        }
        for(int x: primesBelow1000) {
            if (n.mod(new BigInteger(""+x)).equals(BigInteger.ZERO) && !n.equals(new BigInteger(""+x))) {
                return false;
            }
        }
        return true;
    }
    
}